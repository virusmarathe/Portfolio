//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Untitled
//  @ File Name : WorldObject.cs
//  @ Date : 1/14/2011
//  @ Author : 
//
//
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

using System;
using System.Collections.Generic;

using PsychicNinja.Interface.Engine;
using PsychicNinja.Data.Util;
using PsychicNinja.Data.Patrol;
using System.Diagnostics;

namespace PsychicNinja.Data.Object
{

    public class WorldObject : View
    {
        public const float gravity = 1;
        public const float terminalVelocity = 30;
        public bool isBoundToAnotherPlatform = false;

        public LinkedList<WorldObject> boundObjects;

        protected PatrolModel patrol;

        protected Rectangle collisionRect;

        public Vector2 velocity;
        public bool facingLeft = false;

        protected int lastUpdated;

        public WorldObjectDrawStyle drawStyle;

        public float rotationAngle;
        public PositionState positionMask;
        public ObjectShape shape;
        public bool goThrough;
        public bool isTiled;

        public bool hasGravity;
        protected bool screenScrolls = true;

        public WorldObject floor;

        #region Init

        public WorldObject(Rectangle rect) : this (rect, null, ObjectShape.Rectangle)
        {

        }

        /// <summary>
        /// UI constructor. 
        /// </summary>
        /// <param name="rect">Rectangle in which to draw this object.</param>
        /// <param name="tex">Texture with which to draw this object.</param>
        public WorldObject(Rectangle rect, Texture2D tex) : this (rect, tex, ObjectShape.Rectangle)
        {

        }

        /// <summary>
        /// Game World Constructor.
        /// </summary>
        /// <param name="rect">Rectangle in which to draw this object.</param>
        /// <param name="vel">Velocity this object initially moves with.</param>
        /// <param name="tex">Texture with which to draw this object.</param>
        /// <param name="shape">Shape of this object for collision purposes.</param>
        public WorldObject (Rectangle rect, Texture2D tex, ObjectShape newShape) : base(rect, tex)
        {
            rotationAngle = 0.0f;
            lastUpdated = 0;
            positionMask = PositionState.NotSet;
            velocity = Vector2.Zero;
            drawStyle = WorldObjectDrawStyle.StretchToFit;

            collisionRect = drawRect;
            shape = newShape;
            boundObjects = new LinkedList<WorldObject>();
            hasGravity = false;
        }

        /// <summary>
        /// World Object Constructor
        /// </summary>
        /// <param name="rect"></param>
        /// <param name="texName"></param>
        public WorldObject (Rectangle rect, string texName) : this (rect, Content.Load<Texture2D>(texName), ObjectShape.Rectangle)
        {

        }


        #endregion

        #region Life Cycle

        /// <summary>
        /// Default Update for WorldObject and subclasses. Moves this object by its velocity.
        /// </summary>
        /// <param name="timeElapsed">Amount of game time in seconds. May be ignored.</param>
        public virtual void Update(int timeElapsed)
        {
            if (timeElapsed == lastUpdated) return; // Don't update if time isnt flowing
            lastUpdated = timeElapsed;

            if (!isBoundToAnotherPlatform)
            {
                Vector2 newVel = velocity;
                if (hasGravity)
                    newVel.Y += gravity;
                if (newVel.Y > terminalVelocity)
                    newVel.Y = terminalVelocity;
                velocity = newVel;

                if (velocity.Equals(Vector2.Zero)) return;

                int xoff = (int)newVel.X;
                int yoff = (int)newVel.Y;

                MoveFrame(xoff, yoff);

                foreach (WorldObject w in boundObjects)
                {
                    w.MoveFrame(xoff, yoff);
                    //w.AddBindVelocity(newVel);
                }
            }

            collisionRect = drawRect;
            if (patrol != null)
            {
                velocity = patrol.getCurrentVector(timeElapsed);
            }
        }

        /// <summary>
        /// Default Draw for WorldObject. Draws the object.
        /// </summary>
        /// <param name="spriteBatch">SpriteBatch to draw the object with.</param>
        public override void Draw(SpriteBatch spriteBatch)
        {
            Draw(spriteBatch, Color.White, SpriteEffects.None);
        }

        public override void Draw(SpriteBatch spriteBatch, Color color)
        {
            Draw(spriteBatch, color, SpriteEffects.None);
        }

        public void Draw(SpriteBatch spriteBatch, Color color, SpriteEffects effects)
        {
            if (!drawRect.Intersects(Spotlight.viewArea)) 
                return;
            
            Rectangle modDrawRect = ScreenCoordinateDrawFrame();

            switch (drawStyle)
            {
                case WorldObjectDrawStyle.StretchToFit:
                    spriteBatch.Draw(drawTex, modDrawRect, null, color, 0, Vector2.Zero, effects, 0);
                    break;
                case WorldObjectDrawStyle.Rotating:
                    modDrawRect.X += modDrawRect.Width / 2;
                    modDrawRect.Y += modDrawRect.Height / 2;

                    spriteBatch.Draw(drawTex, modDrawRect, null, color, rotationAngle, new Vector2(modDrawRect.Width / 2, modDrawRect.Height / 2), effects, 0);
                    break;
                case WorldObjectDrawStyle.Tiled:
                    spriteBatch.End();
                    spriteBatch.Begin(SpriteSortMode.FrontToBack, BlendState.NonPremultiplied, SamplerState.LinearWrap,
                                    DepthStencilState.Default, RasterizerState.CullNone);

                    Vector2 spriteOrigin = new Vector2(modDrawRect.Left, modDrawRect.Top);
                    spriteBatch.Draw(drawTex, spriteOrigin, new Rectangle(0, 0, modDrawRect.Width, modDrawRect.Height), color, 0, Vector2.Zero, 1, SpriteEffects.None, 0);

                    spriteBatch.End();

                    spriteBatch.Begin();
                    break;
            }
        }

        #endregion

        #region Accessors

        #region Getters

        #region Old Mod
        //public Rectangle ModifiedDrawRect()
        //{
        //    if (screenScrolls == false) { return drawRect; }
        //    Vector2 temp = Spotlight.getOffset();
        //    double scale = 1.0;
        //    double rectX = (drawRect.Left - temp.X); //((drawRect.Left - temp.X - 400) * scale) + 400; // adjusts for the offset 
        //    double rectY = (drawRect.Top - temp.Y);//((drawRect.Top - temp.Y - 240) * scale) + 240; // and zoom rate
        //    return new Rectangle((int)rectX, (int)rectY, (int)(drawRect.Width * scale), (int)(drawRect.Height * scale));
        //}
        #endregion

        public Rectangle ScreenCoordinateDrawFrame()
        {
            return new Rectangle(drawRect.Left - (int)Spotlight.offset.X, drawRect.Top - (int)Spotlight.offset.Y, drawRect.Width, drawRect.Height);
        }

        public PositionState getPositionState()
        {
            return positionMask;
        }

        public Vector2 getVelocity()
        {
            return velocity;
        }

        public bool Gravity()
        {
            return hasGravity;
        }

        public Rectangle CollisionFrame()
        {
            return collisionRect;
        }

        public Vector2 Position()
        {
            return new Vector2(drawRect.Left, drawRect.Top);
        }



        public override bool RespondsToWorldTouch(Point p)
        {
            return collisionRect.Contains(p);
        }

        #endregion

        #region Setters

        public void setVelocity(float x, float y)
        {
            velocity = new Vector2(x, y);
        }

        public void setPositionState(PositionState state)
        {
            positionMask = state;
        }

        public void setGravity(bool falls)
        {
            hasGravity = falls;
        }

        #endregion

        #region Modifiers

        /// <summary>
        /// Move only the collision rectangle for this object. Generally shouldn't be called.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void MoveCollisionFrame(int x, int y)
        {
            collisionRect.Offset(x, y);
        }

        /// <summary>
        /// Move this entire object, draw and collision frames. 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void WorldObjectMove(int x, int y)
        {
            MoveFrame(x, y);
            MoveCollisionFrame(x, y);
        }

        #endregion

        #endregion


        public void bindObject(WorldObject boundObject)
        {
            boundObjects.AddLast(boundObject);
        }

        public void setBind()
        {
            isBoundToAnotherPlatform = true;
        }

        public void releaseBind(WorldObject boundObject)
        {
            isBoundToAnotherPlatform = false;
        }

        public void releaseBind()
        {
            isBoundToAnotherPlatform = false;
        }

        public void AddBindVelocity(Vector2 vel)
        {
            velocity += vel;

        }

        public void SetPatrol(PatrolModel newPatrol)
        {
            patrol = newPatrol;
        }

        public PatrolModel GetPatrol()
        {
            return patrol;
        }

    }

}