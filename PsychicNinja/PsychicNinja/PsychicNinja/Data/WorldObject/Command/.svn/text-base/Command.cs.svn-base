//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Untitled
//  @ File Name : Command.cs
//  @ Date : 1/14/2011
//  @ Author : 
//
//
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PsychicNinja.Data.Util;
using Microsoft.Xna.Framework.Content;
using PsychicNinja.Metrics;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Input.Touch;

/* Command Types
 *  MoveLeft = 0,
    MoveRight = 1,
    Jump = 2,
    WallJump = 3,
    WallSlide = 4,
    LedgeClimb = 5,
    ObjectThrow = 6,
 */

namespace PsychicNinja.Data.WorldObject
{

    public class Command : WorldObject
    {
        private const int commandSize = 70;
        private const int halfCommand = commandSize / 2;

        public bool selected;
        private CommandType type;

        public bool needsTouchLocation = false;
        CommandTarget actionTarget = null;

        public bool FacesLeft = false;
        public LinkedList<Platform> ConnectedPlatforms;

        private static Texture2D[] textures = new Texture2D[7];

        public Command(Point center, CommandType Type)
            : base(new Rectangle(center.X - halfCommand, center.Y - halfCommand, commandSize, commandSize), textures[(int)Type])
        {
            type = Type;
            ConnectedPlatforms = new LinkedList<Platform>();

            needsTouchLocation = (type == CommandType.ObjectThrow);
            selected = false;
        }

        public static new void LoadContent(ContentManager Content)
        {
            textures[0] = Content.Load<Texture2D>("Commands/MoveLeft");
            textures[1] = Content.Load<Texture2D>("Commands/MoveRight");
            textures[2] = Content.Load<Texture2D>("Commands/Jump");
            textures[3] = Content.Load<Texture2D>("Commands/WallJump");
            textures[4] = Content.Load<Texture2D>("Commands/WallSlide");
            textures[5] = Content.Load<Texture2D>("Commands/LedgeClimb");
            textures[6] = Content.Load<Texture2D>("Commands/UseItem");
        }

        /// <summary>
        /// Update the command object. Only exists to make sure base.Update doesn't get called. Commands NEVER move.
        /// </summary>
        /// <param name="timeElapsed"></param>
        public override void Update(int timeElapsed)
        {

        }


        public CommandType getCommandType()
        {
            return type;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            SpriteEffects effect = FacesLeft? SpriteEffects.FlipHorizontally : SpriteEffects.None;
            if (selected)
                base.Draw(spriteBatch, Color.LightCyan, effect);
            else
                base.Draw(spriteBatch, Color.White, effect);

            if (actionTarget == null) return;
            if (selected)
                actionTarget.Draw(spriteBatch);
        }

        /// <summary>
        /// Adds the platform to our list of connections if it intersects the command.
        /// </summary>
        /// <param name="p"></param>
        public bool ConnectToPlatform(Platform p)
        {
            if (!Contains(p.DrawFrame())) return false;

            if (type == CommandType.Jump || type == CommandType.MoveLeft || type == CommandType.MoveRight || type == CommandType.ObjectThrow) return false;
            
            ConnectedPlatforms.AddLast(p);
            FacesLeft = GetCenter().X < p.GetCenter().X;
            return true;
            
        }

        public void ClearConnectedPlatforms()
        {
            ConnectedPlatforms.Clear();
        }

        /// <summary>
        /// Checks to see if the rectangle Collides with any connected platforms.
        /// </summary>
        /// <param name="rect"></param>
        /// <returns></returns>
        public Platform CollidesWithConnectedPlatforms(Rectangle rect)
        {
            foreach (Platform p in ConnectedPlatforms)
            {
                if (p.Contains(rect))
                    return p;
            }
            return null;
        }

        public new bool ProcessTouch(GestureSample gesture)
        {
            Point localGesturePoint = Spotlight.TranslateScreenVectorToWorld(gesture.Position);
            if (RespondsToTouchAtWorldPoint(localGesturePoint))
            {
                selected = true;

                switch (gesture.GestureType)
                {
                    case GestureType.Tap:
                        selected = true;
                        break;
                    case GestureType.FreeDrag:
                        SetCenter(localGesturePoint);
                        break;
                }
                return true;
            }
            else if (actionTarget != null && actionTarget.ProcessTouch(gesture))
            {
                
                return true;
            }
            else
            {
                selected = false;
                return false;
            }

        }

        public void setSecondaryTouchLocation(Point p)
        {
            actionTarget = new CommandTarget(p);
        }

        public Point secondaryTouchLocation()
        {
            return actionTarget.GetCenter();
        }
    }
}