//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Untitled
//  @ File Name : Player.cs
//  @ Date : 1/14/2011
//  @ Author : 
//
//

using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

using PsychicNinja.Data.Patrol;
using PsychicNinja.Interface;
using PsychicNinja.Data.Util;
using System.Diagnostics;
using System.IO;

namespace PsychicNinja.Data.WorldObject
{

    public class Player : WorldObject
    {
        private const int NINJA_WIDTH = 50;
        private const int NINJA_HEIGHT = 75;

        #region Textures
        private static Texture2D NinjaTexture;

        //Running Animation
        private static List<Texture2D> RunTextures;
        private static AnimationComponent running;

        //Jumping Animation
        private static List<Texture2D> JumpTextures;
        private static AnimationComponent jumping;

        //Jumping Animation
        private static List<Texture2D> AirborneTextures;
        private static AnimationComponent airborne;

        //Wall Jump Animation (unfinished)
        private static List<Texture2D> WallJumpTextures;
        private static AnimationComponent wallJumping;

        //Wall Climb Animation (unfinished)
        private static List<Texture2D> WallClimbTextures;
        private static AnimationComponent wallClimbing;
        #endregion

        private const int NinjaRunSpeed = 7;
        private const int NinjaJumpHeight = -18;
        private const int NinjaWallSlideSpeed = 3;

        private int NinjaMovement = 0;
        public LifeState ninjaLifeState;
        private NinjaActionState actionState;

        public bool moveLeft = false;
        public bool moveRight = false;


        private CollisionType crushStatus = CollisionType.CollisionNone;
        private Rope onThisRope;
        public Item HeldItem;
        public Platform attachedPlatform = null;


        #region Init

        public Player(Point topLeft) :
            base(new Rectangle(topLeft.X, topLeft.Y, NINJA_WIDTH, NINJA_HEIGHT), NinjaTexture)
        {
            velocity = Vector2.Zero;
            NinjaMovement = NinjaRunSpeed;

            ninjaLifeState = LifeState.Alive;
            hasGravity = true;
            actionState = NinjaActionState.Standing;

            running = new AnimationComponent(RunTextures, GetDrawFrameX(), GetDrawFrameY(), NINJA_WIDTH, NINJA_HEIGHT);
            jumping = new AnimationComponent(JumpTextures, GetDrawFrameX(), GetDrawFrameY(), NINJA_WIDTH, NINJA_HEIGHT);
            airborne = new AnimationComponent(AirborneTextures, GetDrawFrameX(), GetDrawFrameY(), NINJA_WIDTH, NINJA_HEIGHT);
            //wallJumping = new AnimationComponent(WallJumpTextures, GetDrawFrameX(), GetDrawFrameY(), NINJA_IMAGE_X, NINJA_IMAGE_Y);
            //wallClimbing = new AnimationComponent(WallClimbTextures, GetDrawFrameX(), GetDrawFrameY(), NINJA_IMAGE_X, NINJA_IMAGE_Y);
        }

        /// <summary>
        /// Return a copy of the existing player. Used to create a ghost player for wall slide.
        /// </summary>
        /// <returns></returns>
        public Player Copy()
        {
            Player ret = new Player(Location());
            ret.ninjaLifeState = ninjaLifeState;
            ret.velocity = velocity;
            ret.hasGravity = hasGravity;
            return ret;

        }

        /// <summary>
        /// Causes this class to load its required content into memory for future referencing.
        /// </summary>
        /// <param name="Content"></param>
        public static new void LoadContent(ContentManager Content)
        {
            RunTextures = new List<Texture2D>();
            JumpTextures = new List<Texture2D>();
            AirborneTextures = new List<Texture2D>();
            WallClimbTextures = new List<Texture2D>();
            WallJumpTextures = new List<Texture2D>();
            NinjaTexture = Content.Load<Texture2D>("Ninja/NinjaPixel-Rough");

            RunTextures.Add(Content.Load<Texture2D>("Ninja/NinjaRun_1"));
            RunTextures.Add(Content.Load<Texture2D>("Ninja/NinjaRun_2"));
            RunTextures.Add(Content.Load<Texture2D>("Ninja/NinjaRun_3"));
            RunTextures.Add(Content.Load<Texture2D>("Ninja/NinjaRun_4"));
            RunTextures.Add(Content.Load<Texture2D>("Ninja/NinjaRun_5"));

            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump1"));
            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump2"));
            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump3"));
            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump4"));
            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump5"));
            JumpTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump6"));

            AirborneTextures.Add(Content.Load<Texture2D>("Ninja/NinjaJump1"));
            //running = new AnimationComponent(RunTextures, drawRect.X, drawRect.Y, NINJA_IMAGE_X, NINJA_IMAGE_Y);
        }


        #endregion

        #region Life Cycle

        public override void Update(int gameTime)
        {
            //only update the ninja if he is not dead
            if (ninjaLifeState == LifeState.Dead) return;
            
            crushStatus = CollisionType.CollisionNone;//resetting crushStatus so that collisions from the last upadate are not confused with ones from this update
                
            if (positionMask != PositionState.OnRope)
                rotationAngle = 0.0f;
                
            // Change the Animation State of the Ninja
            switch(actionState)
            {
                case NinjaActionState.Standing:
                    
                    break;
                case NinjaActionState.Airborne:
                    airborne.Update(gameTime);
                    break;
                case NinjaActionState.Running:
                    velocity.X = NinjaMovement;
                    running.Update(gameTime);
                    break;
                case NinjaActionState.Jumping:
                    jumping.Update(gameTime);
                    if (jumping.animationComplete())
                    {
                        actionState = NinjaActionState.Airborne;
                        jumping.reset();
                    }
                    velocity.X = NinjaMovement;
                    break;
                case NinjaActionState.WallJumping:
                    velocity.X = NinjaMovement;
                    break;
                case NinjaActionState.WallSliding:
                    velocity.X = 0;
                    velocity.Y = NinjaWallSlideSpeed;
                    break;

            }


            //If in the air and not jumping, you are airborne
            if (positionMask == PositionState.InAir && actionState != NinjaActionState.Jumping)
            {
                actionState = NinjaActionState.Airborne;
            }
            //If you are airborne and then hit ground, you are running
            else if (positionMask == PositionState.OnFloor)
            {
                actionState = NinjaActionState.Running;
                airborne.reset();
            }

            if (HeldItem!=null && !HeldItem.isFired)
            {
                Point itemPos = this.Location();
                itemPos.X = itemPos.X + NINJA_WIDTH / 2;
                HeldItem.SetPosition(itemPos);
            }
            base.Update(gameTime);
        }


        /// <summary>
        /// Causes this object to draw itself. Assumes the given spriteBatch is already started.
        /// </summary>
        /// <param name="spriteBatch"></param>
        public override void Draw(SpriteBatch spriteBatch)
        {
            if (ninjaLifeState == LifeState.Dead) return;

            SpriteEffects effect = facingLeft ? SpriteEffects.FlipHorizontally : SpriteEffects.None;

            switch(actionState)
            {
                case NinjaActionState.Airborne:
                    airborne.Draw(spriteBatch, modifiedDrawRect(), effect);
                    break;
                case NinjaActionState.Running:
                    running.Draw(spriteBatch, modifiedDrawRect(), effect);
                    break;
                case NinjaActionState.Jumping:
                    jumping.Draw(spriteBatch, modifiedDrawRect(), effect);
                    break;
                default:
                    if (facingLeft) spriteBatch.Draw(drawTex, modifiedDrawRect(), new Rectangle(0, 0, NINJA_WIDTH, NINJA_HEIGHT), Color.White, rotationAngle, new Vector2(0, 0), SpriteEffects.FlipHorizontally, 0.5f);
                    else spriteBatch.Draw(drawTex, modifiedDrawRect(), new Rectangle(0, 0, NINJA_WIDTH, NINJA_HEIGHT), Color.White, rotationAngle, new Vector2(0, 0), SpriteEffects.None, 0.5f);
                    break;
            }

            if (HeldItem != null)
            {
                HeldItem.Draw(spriteBatch);
            }
        }
        #endregion


        #region Actions

        /// <summary>
        /// Change the ninjas direction of motion.
        /// </summary>
        /// <param name="goLeftYoungMan">Whether or not the ninja will go left from now on.</param>
        public void Action_Move(bool goLeftYoungMan)
        {
            if (facingLeft == goLeftYoungMan) return; // Don't change anything if we're already going this way.

            NinjaMovement = goLeftYoungMan? -NinjaRunSpeed : NinjaRunSpeed;

            facingLeft = goLeftYoungMan;

        }

        /// <summary>
        /// Makes the ninja jump.
        /// </summary>
        public void Action_Jump()
        {
            if (positionMask == PositionState.OnFloor)
            {
                velocity.Y = NinjaJumpHeight;
                positionMask = PositionState.InAir;
                actionState = NinjaActionState.Jumping;
            }
            else if (positionMask == PositionState.OnRope)
            {
                velocity.Y = NinjaJumpHeight;
                positionMask = PositionState.InAir;
                onThisRope.ropeRelease(true);
                actionState = NinjaActionState.Jumping;
            }
        }

        /// <summary>
        /// Makes the ninja wall jump.
        /// </summary>
        /// <param name="fLeft"></param>
        public void Action_WallJump(Command c)
        {
            if (c.CollidesWithConnectedPlatforms(DrawFrame()) != null)
            {
                velocity.Y = NinjaJumpHeight;
                Action_Move(c.FacesLeft);
                actionState = NinjaActionState.WallJumping;
            }
        }
        
        /// <summary>
        /// Makes the ninja slide on a wall associated with the command passed in.
        /// </summary>
        public void Action_WallSlide(Command c)
        {
            if (c.CollidesWithConnectedPlatforms(DrawFrame()) != null)
            {
                actionState = NinjaActionState.WallSliding;
            }
        }

        /// <summary>
        /// Makes the ninja climb a ledge associated with the command passed in.
        /// </summary>
        /// <param name="c"></param>
        public void Action_LedgeClimb(Command c)
        {
            Platform p = c.CollidesWithConnectedPlatforms(DrawFrame());
            if (p == null) return;

            if (GetDrawFrameY() < p.GetDrawFrameY())
            {
                actionState = NinjaActionState.WallClimbing;
                //animatedFrameSlide(new Point(NINJA_WIDTH, 0), 15, true);
                //animatedFrameSlide(new Point(0, GetDrawFrameY() - p.GetDrawFrameY()), 15, false);
                WorldObjectMove(NINJA_WIDTH, GetDrawFrameY() - p.GetDrawFrameY());
                velocity.Y = 0;
            }
        }

        public void Action_RopeSwing(Rope r)
        {
            positionMask = PositionState.OnRope;
            onThisRope = r;
            SetPosition(new Point(r.CollisionFrame().X, r.CollisionFrame().Y));
            rotationAngle = r.getRotationAngle();
            velocity = new Vector2(velocity.X, 0); // No more falling
        }

        /// <summary>
        /// Make the ninja throw its held item
        /// </summary>
        public void Action_ThrowItem(Command c)
        {
            if (HeldItem != null)
            {
                HeldItem.isFired = true;
                Point direction = new Point(c.secondaryTouchLocation().X - GetCenter().X, c.secondaryTouchLocation().Y - GetCenter().Y);
                HeldItem.SetDirection(direction);
                HeldItem = null;
            }
        }

        #endregion

        /// <summary>
        /// Kills the ninja, preventing him from being updated or drawn
        /// </summary>
        public void death()
        {
            Point p = this.Location();
            Metrics.Metrics.writeLine("Level: City");
            Metrics.Metrics.writeLine("Death Location: ("+p.X+","+p.Y+")");
            ninjaLifeState = LifeState.Dead;
            MoveFrame(-500, -500);
        }
        
        public void squishCheck(CollisionType c)
        {
            if (c == CollisionType.CollisionNone) return;
            // First updates the Player's "crushStatus", which is a record of which sides have hit a platform in this update.
            if (/**/((crushStatus & CollisionType.CollisionBottom) != CollisionType.CollisionBottom) &&
                              ((c & CollisionType.CollisionBottom) == CollisionType.CollisionBottom)/**/)
            { crushStatus |= CollisionType.CollisionBottom; }
            if (/**/((crushStatus & CollisionType.CollisionTop) != CollisionType.CollisionTop) &&
                              ((c & CollisionType.CollisionTop) == CollisionType.CollisionTop)/**/)
            { crushStatus |= CollisionType.CollisionTop; }
            if (((crushStatus & CollisionType.CollisionLeft) != CollisionType.CollisionLeft) &&
                              ((c & CollisionType.CollisionLeft) == CollisionType.CollisionLeft))
            { crushStatus |= CollisionType.CollisionLeft; }
            if (((crushStatus & CollisionType.CollisionRight) != CollisionType.CollisionRight) &&
                              ((c & CollisionType.CollisionRight) == CollisionType.CollisionRight))
            { crushStatus |= CollisionType.CollisionRight; }
            // Then, if the Ninja has struck platforms from two opposite sides (top/bottom or left/right), kill him.
            if (((crushStatus & CollisionType.CollisionBottom) == CollisionType.CollisionBottom) &&
                      ((crushStatus & CollisionType.CollisionTop) == CollisionType.CollisionTop))
            { death(); return; }
            if (((crushStatus & CollisionType.CollisionLeft) == CollisionType.CollisionLeft) &&
                      ((crushStatus & CollisionType.CollisionRight) == CollisionType.CollisionRight))
            { death(); return; }
        }


    }
}