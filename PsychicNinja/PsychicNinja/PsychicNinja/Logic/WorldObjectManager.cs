//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Untitled
//  @ File Name : WorldObjectManager.cs
//  @ Date : 1/14/2011
//  @ Author : 
//
//
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Input.Touch;
using Microsoft.Xna.Framework.Media;

using PsychicNinja.Data.Patrol;
using PsychicNinja.Interface.Engine;
using PsychicNinja.Interface;
using PsychicNinja.Data.Util;
using PsychicNinja.Data.Parser;
using PsychicNinja.Data.Object;
using PsychicNinja.Logic;
using PsychicNinja.Metrics;
using PsychicNinja.Data.Object.Entity;

public class WorldObjectManager
{
    CommandMenu commandMenu;
    private bool temporarilyHidingMenu = false;

    private LinkedList<Platform>    listOfWorldPlatforms = new LinkedList<Platform>();
    private LinkedList<Enemy>       listOfWorldEnemies = new LinkedList<Enemy>();
    private LinkedList<Doodad>      listOfWorldDoodads = new LinkedList<Doodad>();
    private LinkedList<Item>        listOfWorldItems = new LinkedList<Item>();
    private LinkedList<Rope>        listOfHangingRopes = new LinkedList<Rope>();
    private LinkedList<SuspendRope> listOfSuspendRopes = new LinkedList<SuspendRope>();
    private LinkedList<Trigger>     listOfTriggers = new LinkedList<Trigger>();
    private Dialogue thoughts;

    private RenderTarget2D rt;

    private Point startlocation;
    private WorldObject goalregion;
    private static Texture2D goalRegionTexture;

    private Player ninja;
    
    // sword to Platform logic variables will move these to a more elegant place later
    private Platform swordPlatform;
    private Item removedItem;
    private Boolean swordToPlatform;

    private int attemptsCounter = 0;

    private string levelSourceFilename;

    private Layer[] backgroundLayers;

    public WOMState WOMstate;

    int faketimer;
    bool firstTimeHint = true;

    public TimeSpan StartTime;
    public TimeSpan TimeRecord;

    //array containing information on commands in this level; 
    //referrence as commandLimits[type, (0 for limit; 1 for number placed)]
    public int[,] commandLimits;


    /// <summary>
    /// Constructor.
    /// </summary>
    /// <param name="Content">The content manager to load from.</param>
    public WorldObjectManager(GraphicsDeviceManager gdm, ContentManager Content, string filename, int levelnum)
    {

        WOMstate = WOMState.InLevel;
        commandLimits = new int[(int)CommandType.NumCommands, 2];

        levelSourceFilename = filename;
        LevelParser.setReadTarget(levelSourceFilename);
        thoughts = new Dialogue(new Rectangle(0, 0, 0, 0), levelnum);        
        LoadLevel(gdm, Content);
        faketimer = 0;
    }

    private void NewNinja()
    {
        ninja = new Player(startlocation);
        ninja.setDialogue(thoughts);
        Spotlight.SetSpotlightFocus(ninja);
    }

    /// <summary>
    /// Reset the level. Clear out data caches and reload from file.
    /// </summary>
    public void resetButton(ContentManager Content)
    {
        LoadLevelDynamic(Content);
        NewNinja();

        commandMenu.ResetCommandCharges();

        if (temporarilyHidingMenu)
        {
            commandMenu.Show();
            temporarilyHidingMenu = false;
        }

        attemptsCounter++;
        Metrics.writeLine("Number of attempts:" + attemptsCounter);
        
    }


    public static void LoadContent(ContentManager Content)
    {
        goalRegionTexture = Content.Load<Texture2D>("eyeopen");

    }

    #region Level Loading

    /// <summary>
    /// Uses LevelParser to read all content from the level.  Also, load animations, cuz I said so.
    /// </summary>
    /// <param name="Content"></param>
    public void LoadLevel(GraphicsDeviceManager gdm, ContentManager Content)
    {
        Enemy.UnloadContent();

        LoadLevelStatic(gdm, Content);
        LoadLevelDynamic(Content);
        Spotlight.SetZoomedOut();
        commandMenu.Hide();
    }


    /// <summary>
    /// Uses LevelParser to read static content from the level.
    /// </summary>
    /// <param name="Content"></param>
    public void LoadLevelStatic(GraphicsDeviceManager gdm, ContentManager Content)
    {
        Vector2 lb = LevelParser.readLevelBounds();
        Spotlight.setStage(lb);
        Doodad.LoadContent(Content, LevelParser.readDoodadTextures());
        Dialogue.LoadContent(Content);
        //LoadContent(Content, LevelParser.readBackgroundTextures(), LevelParser.readTilesetBehavior());

        LoadLevelBackgrounds(Content, lb);

        CreateRenderBuffer(gdm, lb);

        int[] limits = LevelParser.readCommandLimits();

        //set command limits for this level
        for (int i = 0; i < limits.Length; i++)
            commandLimits[i, 0] = limits[i];

        commandMenu = new CommandMenu(limits);


        Song thislevel = Content.Load<Song>(LevelParser.readLevelMusic()[0]);
        MusicManager.SetSong(thislevel);
        MusicManager.StartMusic();

    }

    const int LevelBoundCapX = 1600; // 2 * Screen width
    const int LevelBoundCapY = 960; // 2 * Screen height

    /// <summary>
    /// Create the render buffer, destroying the old one if necessary.
    /// </summary>
    /// <param name="gdm"></param>
    /// <param name="lb"></param>
    private void CreateRenderBuffer(GraphicsDeviceManager gdm, Vector2 lb)
    {
        //kill the render target just in case
        if (rt != null)
            rt.Dispose();

        float lb2x = lb.X, lb2y = lb.Y;

        float xrat = lb.X / LevelBoundCapX, yrat = lb.Y / LevelBoundCapY;

        if (xrat > yrat)
        {
            lb2x = yrat * LevelBoundCapX;
        }
        else
        {
            lb2y = xrat * LevelBoundCapY;
        }

        float scale = lb2x / LevelBoundCapX;
        if (scale > 1)
        {
            lb2x = 1600;
            lb2y = 960;
            Spotlight.SetMaxZoom(0.5f);
        }
        else if (scale < 0.5)
        {
            lb2x = 800;
            lb2y = 480;
            Spotlight.SetMaxZoom(1.0f);
        }
        else
        {
            Spotlight.SetMaxZoom(0.5f / scale);
        }



        rt = new RenderTarget2D(gdm.GraphicsDevice, (int)lb2x, (int)lb2y);
    }

    /// <summary>
    /// Read in and size the background based on level boundaries.
    /// </summary>
    /// <param name="Content"></param>
    /// <param name="lb"></param>
    private void LoadLevelBackgrounds(ContentManager Content, Vector2 lb)
    {
        //load information for background layers
        string[] bglayers = LevelParser.readBackgroundTextures();
        backgroundLayers = new Layer[4];
        Texture2D[] bgtex = new Texture2D[4];

        for (int i = 0; i < bglayers.Length; i++)
        {
            if (bglayers[i] != null)
                bgtex[i] = Content.Load<Texture2D>(bglayers[i]);
        }

        if (bglayers[2] == "backlayer2") //case where we're using clouds as the scrolling layer
        {
            backgroundLayers[1] = new Layer(new Rectangle(0, 0, (int)lb.X, (int)lb.Y), bgtex[1], LayerBehaviorType.FarBG);
            backgroundLayers[2] = new Layer(new Rectangle(0, 0, (int)lb.X, 300), bgtex[2], LayerBehaviorType.Cloud);
        }
        else if (bglayers[2] == "cavebacklayerscrolling") //case where we're using the cave's fog
        {

            backgroundLayers[1] = new Layer(new Rectangle(0, 0, (int)lb.X, (int)lb.Y), bgtex[2], LayerBehaviorType.Fog);
            backgroundLayers[2] = new Layer(new Rectangle(0, 0, (int)lb.X, (int)lb.Y), bgtex[1], LayerBehaviorType.FarBG);
        }

        backgroundLayers[0] = new Layer(new Rectangle(0, 0, (int)lb.X, (int)lb.Y), bgtex[0], LayerBehaviorType.NearBG); //closest layer
        backgroundLayers[3] = new Layer(new Rectangle(0, 0, (int)lb.X, (int)lb.Y), bgtex[3], LayerBehaviorType.Static); //furthest layer
    }

    /// <summary>
    /// Uses LevelParser to read dynamics parts in level.
    /// </summary>
    public void LoadLevelDynamic(ContentManager Content)
    {
        startlocation = LevelParser.readStartLocation();
        
        if (ninja != null)
            ninja.SetPosition(startlocation);
        listOfWorldPlatforms = LevelParser.readPlatforms();
        listOfWorldItems = LevelParser.readItems();

        listOfWorldEnemies = LevelParser.readEnemies();
        foreach (Enemy e in listOfWorldEnemies)
            Enemy.LoadContent(Content, e.GetEnemyType());

        listOfWorldDoodads = LevelParser.readDoodads();
        listOfSuspendRopes = LevelParser.readRopes();


        //add ninja sprite as a doodad for start location

        goalregion = new WorldObject(LevelParser.readGoalRegion(), goalRegionTexture);

        foreach (Platform p in listOfWorldPlatforms)
        {
            foreach (Trigger t in p.triggers)
            {
                listOfTriggers.AddLast(t);
            }
        }
        ConnectSuspendPlatforms();

    }

    private void ConnectSuspendPlatforms()
    {

        foreach (Platform p in listOfWorldPlatforms)
        {
            foreach (SuspendRope s in listOfSuspendRopes)
            {
                if (p.drawRect.Intersects(s.drawRect) && s.drawRect.Top < p.drawRect.Top)
                    p.addRope(s);
            }
        }

    }

    #endregion

    /// <summary>
    /// Get the player object.
    /// </summary>
    /// <returns></returns>
    public WorldObject playerObject()
    {
        return ninja;
    }

    /// <summary>
    /// Temporarily hides the command menu until reset is called.  If the command menu is already hidden,
    /// nothing will happen.
    /// </summary>
    /// <returns></returns>
    public void HideCommandMenuTemporarily()
    {
        if (commandMenu.show)
        {
            temporarilyHidingMenu = true;
            commandMenu.Hide();
        }
    }

    /// <summary>
    /// Update all objects associated with this manager.
    /// </summary>
    /// <param name="timeElapsed"></param>
    public void UpdateAll(int timeElapsed, GameState gameRunState)
    {
        //asdf.Update();
        int collisionState = 0;

        if (ninja.drawRect.Intersects(goalregion.drawRect) && (ninja.positionMask == PositionState.OnFloor) && ninja.ninjaLifeState == LifeState.Alive)
        {
            WOMstate = WOMState.LevelComplete;
            thoughts.setDialogueNumber(thoughts.getDialogueNumber() + 1);
            return;
        }

        //case where we just pressed the start button
        if (WOMstate == WOMState.RunningLevel)
        {
            //cancel the ninja warping animation
            ninja.EndWarpAnimation();
        }

        commandMenu.Update();
        commandMenu.UpdateAnimations(timeElapsed);
        if (gameRunState == GameState.StateRunning && timeElapsed != 0)
        {
            commandMenu.CommandCollisions(ninja, listOfWorldPlatforms);
            firstTimeHint = false;
            thoughts.Update(timeElapsed);
        }
        else
        {
            if (!firstTimeHint)
            {
                thoughts.showDialog(false);
            }
            thoughts.Update(timeElapsed);
        }


        ninja.Update(timeElapsed);


        if (ninja.drawRect.Y > Spotlight.stageCorner.Y)
            ninja.fallDeath();



        faketimer++;
        backgroundLayers[2].Update(faketimer);
        backgroundLayers[1].Update(faketimer);
        backgroundLayers[0].Update(faketimer);

        foreach (Enemy e in listOfWorldEnemies)
            e.Update(timeElapsed, ninja);

        foreach (Platform p in listOfWorldPlatforms)
            p.Update(timeElapsed);

        if (gameRunState != GameState.StateRunning)
            return;
        
        List<Platform> ninjaCollisions = new List<Platform>(); //List of platforms that the ninja collides with
        List<int> collisionStates = new List<int>();           //List of corresponding collisionStates

        //NOTE: Platform collisions will have the same "wall clinging" problem until we create collisionLists for
        //those as well.  These cases would only happen when platforms moving diagonally.


        

        foreach (Rope r in listOfHangingRopes)
            r.Update(timeElapsed);

        foreach (SuspendRope s in listOfSuspendRopes)
            s.Update(timeElapsed);

        foreach (Item item in listOfWorldItems)
            item.Update(timeElapsed);

        //Tests for collision between ninja and all platforms, and also all platforms against all other platforms
        //Also, tests to see if there are any obstructions in the areas where the ninja might wall climb from the top
        //right or left sides
        foreach (Platform p in listOfWorldPlatforms)
        {
            collisionState = Collision.checkCollisions(ninja, p);
            if (collisionState != 0)
            {
                if (p.isHazardous)
                {
                    ninja.death();
//                    thoughts.showDialog(true);
                }
                collisionStates.Add(collisionState);
                ninjaCollisions.Add(p);            //store the platform object in a List
            }

            // Don't check collisions if this platform isn't moving.
            if ((p.velocity == Vector2.Zero && p.triggers.Count == 0) || p.goThrough) continue;
            foreach (Platform q in listOfWorldPlatforms)
            {
                // Don't check collisions against itself
                if (p == q) continue;
                if (q.goThrough) continue;

                collisionState = Collision.checkCollisions(p, q);
                if (collisionState != 0)
                    Collision.collisionResolution(collisionState, p, q);
                
            }
        }

        foreach (Trigger t in listOfTriggers)
        {
            if (ninja.drawRect.Intersects(t.drawRect))
                t.attachedTo.StartPatrol(timeElapsed);
            foreach (Enemy e in listOfWorldEnemies)
            {
                if (e.drawRect.Intersects(t.drawRect))
                {
                    t.attachedTo.StartPatrol(timeElapsed);
                }
            }
        }
        /*
        //Test for collision between ropes and ninja
        foreach (Rope r in listOfHangingRopes)
        {
            collisionState = Collision.checkCollisions(ninja, r);
            r.setHasNinja(collisionState != 0);
            if (collisionState != 0)
            {
                r.resolveCollisionWithObject(collisionState, ninja);
            }
            else if (collisionState == 0)
            {
                r.setRotationAngle(0.0f);
            }
            r.Update(timeElapsed);
        }*/
        #region Items to WorldObjects
        foreach (Item item in listOfWorldItems)
        {
            if (ninja.drawRect.Intersects(item.drawRect) && ninja.HeldItem == null && item.isUsed == false)
            {
                ninja.HeldItem = item;
                ninja.HeldItem.isHeld = true;
            }

            if (!item.isUsed) continue;
            
            //Check if item hits platform, and if so, then bind item to platform
            foreach (Platform p in listOfWorldPlatforms)
            {
                collisionState = Collision.checkCollisions(p, item);
                item.isHeld = false;
                if (collisionState != 0)
                {
                    item.setVelocity(0, 0);
                    item.setGravity(false);

                    switch (item.type)
                    {
                        case ItemType.Shuriken:
                            if(item.isBoundToAnotherPlatform == false) p.bindObject(item);
                            item.setBind();
                            item.isUsed = false;
                            break;
                        case ItemType.Sword:
                            Rectangle r = item.drawRect;
                            swordPlatform = new Platform(r, item.drawTex, false, false, false, false, false);
                            swordPlatform.drawStyle = WorldObjectDrawStyle.Rotating;
                            if (collisionState == 1) swordPlatform.rotationAngle = (float)(180*Item.radian);
                            else if (collisionState == 2) swordPlatform.rotationAngle = (float)(270* Item.radian);
                            else if(collisionState == 3) swordPlatform.rotationAngle = 0;
                            else if (collisionState == 4) swordPlatform.rotationAngle = (float)(90 * Item.radian);
                            
                            removedItem = item;
                            if (!item.isBoundToAnotherPlatform) p.bindObject(swordPlatform);
                            swordPlatform.setBind();
                            swordToPlatform = true;
                            break;

                    }

                    item.platformCheck(p);

                }
                //Test collision between shuriken and rope
                if (item.type == ItemType.Shuriken)
                {

                    List<SuspendRope> ropes = p.suspendRopes;
                    for (int j = 0; j < ropes.Count; j++)
                    {
                        if (item.drawRect.Intersects(ropes[j].drawRect))
                        {
                            MusicManager.PlaySoundEffect(SoundEffects.cutRope);
                            p.cutRope(ropes[j]);
                        }
                    }
                }
                
            }
            foreach (Enemy e in listOfWorldEnemies)
            {
                collisionState = Collision.checkCollisions(item, e);
                if (collisionState != 0)
                {
                    item.enemyCheck(e);
                }
            }
            
        }
        if (swordToPlatform)
        {
            MusicManager.PlaySoundEffect(SoundEffects.swordCollide);
            listOfWorldPlatforms.AddLast(swordPlatform);            
            listOfWorldItems.Remove(removedItem);
            swordToPlatform = false;
        }
        #endregion

        #region Enemy collisions
        foreach (Enemy e in listOfWorldEnemies)
        {
            if (!e.IsAlive()) continue;

            //Tests for collision between ninja and all enemies
            collisionState = Collision.checkCollisions(ninja, e);
            if (collisionState != 0)
            {
                if (ninja.HeldItem != null && ninja.HeldItem.type == ItemType.Sword)
                {
                    ninja.Action_SwingSword();
                    MusicManager.PlaySoundEffect(SoundEffects.deathsound1);
                    e.death();
                }
                else
                {
                    e.attack();
                    if (ninja.ninjaLifeState == LifeState.Alive)
                    {
                        ninja.villainDeath();
                        thoughts.showDialog(true);
                    }
                }
            }

            //enemy-platform collision
            foreach (Platform p in listOfWorldPlatforms)
            {
                collisionState = Collision.checkCollisions(e, p);


                if (collisionState == 3)
                {
                    if (gameRunState == GameState.StateRunning && e.positionMask == PositionState.OnFloor) e.WorldObjectMove((int)p.velocity.X, (int)e.velocity.Y);
                    
                }
                if (collisionState != 0)
                    Collision.collisionResolution(collisionState, e, p);
            }
        }

        #endregion

        //If ninja collided with nothing except for the screen boundries, set its state to InAir
        if (ninjaCollisions.Count == 0 /*&& ninja.drawRect.Height != 400*/)
            ninja.positionMask = PositionState.InAir;


        //If the ninja hits multiple objects from the same side, make sure that the resolution only happens once <-- BAD
        //Its bad because it prevents platforms from going through other platforms while the ninja is on one
        bool c1 = false, c2 = false, c3 = false, c4 = false;

        //This area resolves the ninja->platform collisions
        //We need to resolve left/right collisions first
        //NOTE: In a foreach loop, you can't delete elements of a list you are iterating through
        for (int i = 0; i < ninjaCollisions.Count; ++i)
        {
            switch(collisionStates[i])
            {
                case 2:
                    Collision.collisionResolution(collisionStates[i], ninja, ninjaCollisions[i]);
                    c2 = true;
                    break;
                case 4:
                    Collision.collisionResolution(collisionStates[i], ninja, ninjaCollisions[i]);
                    c4 = true;
                    break;
            }
        }



        //Recheck for collisions and see if there are any top/down cases left

        //If so, then resolve them
        for (int i = 0; i < ninjaCollisions.Count; ++i)
        {
            collisionState = Collision.checkCollisions(ninja, ninjaCollisions[i]);
            if (collisionState != 0)
            {
                switch (collisionState)
                {
                    case 1:
                        Collision.collisionResolution(collisionStates[i], ninja, ninjaCollisions[i]);
                        c1 = true;
                        break;
                    case 3:
                        Collision.collisionResolution(collisionStates[i], ninja, ninjaCollisions[i]);
                        //Only move the ninja with his "bound" platform if
                        if (gameRunState == GameState.StateRunning && ninja.positionMask == PositionState.OnFloor)
                        {
                            Platform p = ninjaCollisions[i];
                            if (p.velocity.Y > 0) ninja.WorldObjectMove((int)ninjaCollisions[i].velocity.X, (int)(ninjaCollisions[i].velocity.Y - 1));
                            else if (p.velocity.Y < 0) ninja.WorldObjectMove((int)ninjaCollisions[i].velocity.X, (int)ninja.velocity.Y/*(int)ninjaCollisions[index].velocity.Y*/);
                            //if (p2.velocity.Y >= 0) 
                            //ninja.setVelocity(ninja.velocity.X, ninja.velocity.Y + p2.velocity.Y);
                        }
                        c3 = true;
                        break;
                }
            }
        }
    

        ninja.squishCheck(c1, c2, c3, c4);

    }

    /// <summary>
    /// Make each object we own draw itself. 
    /// </summary>
    /// <param name="spriteBatch"></param>
    public void DrawAll(SpriteBatch spriteBatch)
    {
        spriteBatch.End();
        spriteBatch.GraphicsDevice.SetRenderTarget(rt);
        spriteBatch.Begin();

        spriteBatch.Draw(goalRegionTexture, Rectangle.Empty, Color.White);

        backgroundLayers[3].Draw(spriteBatch);
        backgroundLayers[2].Draw(spriteBatch);
        backgroundLayers[1].Draw(spriteBatch);
        backgroundLayers[0].Draw(spriteBatch);
        
        goalregion.Draw(spriteBatch);

        ninja.Draw(spriteBatch);

      
        foreach (Platform p in listOfWorldPlatforms)
        {
            p.Draw(spriteBatch);
        }
        foreach (Doodad d in listOfWorldDoodads)
        {
            d.Draw(spriteBatch);
        }
        foreach (Item i in listOfWorldItems)
        {
            i.Draw(spriteBatch);
        }
        foreach (Enemy e in listOfWorldEnemies)
        {
            e.Draw(spriteBatch);
        }

        commandMenu.DrawCommands(spriteBatch);



        spriteBatch.End();
        spriteBatch.GraphicsDevice.SetRenderTarget(null);
        spriteBatch.Begin();


        spriteBatch.Draw(rt, Vector2.Zero, null, Color.White, 0f, Vector2.Zero, Spotlight.getScale(), SpriteEffects.None, 0);
        commandMenu.Draw(spriteBatch);
        thoughts.Draw(spriteBatch);

        //asdf.Draw(spriteBatch);
    }

    #region Collision-moved
    /// <summary>
    /// Andrew's code modified to return the side the collision happened               
    ///        |
    ///        V
    ///     ___1____  
    ///     |       |
    ///--->4| obj1  |2<----
    ///     |_______|
    ///        3  
    ///        ^
    ///        |
    /// <param name="obj1"></param>
    /// <param name="obj2"></param>
    /// <returns>Returns a number corresponding to the side of the collision, relative to Obj1 or 0.</returns>
    /*public int checkCollisions(WorldObject obj1, WorldObject obj2)
    {

        //Vector2s used to determine corner coordinates
        Point obj1Coor = obj1.drawRect.Location;
        Point obj2Coor = obj2.drawRect.Location;
        Point obj1Size = new Point(obj1.drawRect.Width, obj1.drawRect.Height);
        Point obj2Size = new Point(obj2.drawRect.Width, obj2.drawRect.Height);

        //these four variables state how each side is related to obj2's sides; their values represent the following:
        //  1: this side is too far from obj2
        // 10: this side is inside obj2
        //100: this side is too close to obj2
        int leftOffset = 2, rightOffset = 2, topOffset = 2, bottomOffset = 2;

        //check for rectangular collisions; change leftOffset, rightOffset, topOffset, bottomOffset based on 
        //what sides are colliding
        #region RectangleCollisionCheck
        if (obj1.shape == ObjectShape.Rectangle && obj2.shape == ObjectShape.Rectangle)
        {
            //check the position of the left side
            #region leftcheck
            if (obj1Coor.X >= obj2Coor.X)
            {
                //we know obj1's left side is at or to the right of obj2's left side
                if (obj1Coor.X <= obj2Coor.X + obj2Size.X)
                    //we know obj1's left side is between obj2's left and right sides
                    leftOffset = 10;
                else
                    //obj1's left side is to the right of obj2
                    leftOffset = 100;
            }
            else
                //obj1's left side is to the left of obj2
                leftOffset = 1;
            #endregion

            //check the position of the right side
            #region rightcheck
            if (obj1Coor.X + obj1Size.X >= obj2Coor.X)
            {
                //we know obj1's right side is at or to the right of obj2's left side
                if (obj1Coor.X + obj1Size.X <= obj2Coor.X + obj2Size.X)
                    //we know obj1's right side is between obj2's left and right sides
                    rightOffset = 10;
                else
                    //obj1's right side is to the right of obj2
                    rightOffset = 1;
            }
            else
                //obj1's right side is to the left of obj2
                rightOffset = 100;
            #endregion

            //check the position of the top side
            #region topcheck
            if (obj1Coor.Y >= obj2Coor.Y)
            {
                //we know obj1's top side is at or below obj2's top side
                if (obj1Coor.Y <= obj2Coor.Y + obj2Size.Y)
                    //we know obj1's top side is between obj2's top and bottom sides
                    topOffset = 10;
                else
                    //obj1's top side is below obj2
                    topOffset = 100;
            }
            else
                //obj1's top side is above obj2
                topOffset = 1;
            #endregion

            //check the position of the top side
            #region bottomcheck
            if (obj1Coor.Y + obj1Size.Y >= obj2Coor.Y)
            {
                //we know obj1's bottom side is at or below obj2's top side
                if (obj1Coor.Y + obj1Size.Y <= obj2Coor.Y + obj2Size.Y)
                    //we know obj1's bottom side is between obj2's top and bottom sides
                    bottomOffset = 10;
                else
                    //obj1's bottom side is below obj2
                    bottomOffset = 1;
            }
            else
                //obj1's bottom side is above obj2
                bottomOffset = 100;
            #endregion


            //add up the offsets to see what sides are where
            int sum = leftOffset + rightOffset + topOffset + bottomOffset;

            //if any one side is opposite its pair in obj2, there's no way these things can be colliding
            if (sum >= 100)
                return 0;

            //otherwise, check cases of enclosure and intersection
            if (sum == 4) //this object completely surrounds obj2
                return 3;
            else if (sum > 10) // at least one side is inside obj2           
            {
                //These variables used to calculate edge cases
                float Xdist;
                float Ydist;

                //Check cases where only one side intersects
                if (rightOffset == 10 && bottomOffset != 10 && leftOffset != 10 && topOffset != 10)
                    return 2;
                else if (rightOffset != 10 && bottomOffset == 10 && leftOffset != 10 && topOffset != 10)
                    return 3;
                else if (rightOffset != 10 && bottomOffset != 10 && leftOffset == 10 && topOffset != 10)
                    return 4;
                else if (rightOffset != 10 && bottomOffset != 10 && leftOffset != 10 && topOffset == 10)
                    return 1;

                //Check cases where three sides intersect
                else if (bottomOffset == 10 && rightOffset == 10 && leftOffset == 10)
                    return 3;
                else if (bottomOffset == 10 && topOffset == 10 && leftOffset == 10)
                    return 4;
                else if (rightOffset == 10 && topOffset == 10 && leftOffset == 10)
                    return 1;
                else if (bottomOffset == 10 && rightOffset == 10 && topOffset == 10)
                    return 2;

                //Check and calculate corner cases where two sides intersect
                //bot left corner obj1 intersects obj2
                else if (bottomOffset == 10 && leftOffset == 10 && topOffset != 10 && rightOffset != 10)
                {
                    Xdist = obj2Coor.X + obj2Size.X - obj1Coor.X;
                    Ydist = obj2Coor.Y - (obj1Coor.Y + obj1Size.Y);
                    if (Math.Abs(Xdist) > Math.Abs(Ydist))
                    {
                        if (obj1.velocity.Y > 0) //obj1 must be falling DOWN to land on its bottom
                            return 3;
                        else
                            return 4;
                    }
                    else
                        return 4;
                }
                //top left corner obj1 intersects obj2
                else if (bottomOffset != 10 && leftOffset == 10 && topOffset == 10 && rightOffset != 10)
                {
                    Xdist = obj2Coor.X + obj2Size.X - obj1Coor.X;
                    Ydist = obj2Coor.Y + obj2Size.Y - obj1Coor.Y;
                    if (Math.Abs(Xdist) > Math.Abs(Ydist))
                    {
                        if (obj1.velocity.Y < 0) //obj1 must be going UP to hit it's head on a ceiling
                            return 1;
                        else
                            return 4;
                    }
                    else
                        return 4;
                }
                //top right corner obj1 intersects obj2
                else if (bottomOffset != 10 && leftOffset != 10 && topOffset == 10 && rightOffset == 10)
                {

                    Xdist = obj2Coor.X - (obj1Coor.X + obj1Size.X);
                    Ydist = obj2Coor.Y + obj2Size.Y - obj1Coor.Y;
                    if (Math.Abs(Xdist) > Math.Abs(Ydist))
                    {
                        if (obj1.velocity.Y < 0) //obj1 must be going UP to hit it's head on a ceiling
                            return 1;
                        else
                            return 2;
                    }
                    else
                        return 2;
                }
                //bot right corner obj1 intersects obj2
                else if (bottomOffset == 10 && leftOffset != 10 && topOffset != 10 && rightOffset == 10)
                {
                    Xdist = obj2Coor.X - (obj1Coor.X + obj1Size.X);
                    Ydist = obj2Coor.Y - (obj1Coor.Y + obj1Size.Y);
                    if (Math.Abs(Xdist) > Math.Abs(Ydist))
                    {
                        if (obj1.velocity.Y > 0) //obj1 must be falling DOWN to land on its bottom
                            return 3;
                        else
                            return 2;
                    }
                    else
                        return 2;
                }

            }
        }
        #endregion

        return 0; //never happens
    }

    //Depending on the side of collision, calculate how far obj1 is intersecting obj2, and move obj1 out of obj2
    //and set both objects's X or Y velocity to 0
    private void collisionResolution(int collisionState, WorldObject obj1, WorldObject obj2)
    {
        Point obj1Coor = obj1.drawRect.Location;
        Point obj2Coor = obj2.drawRect.Location;
        Point obj1Size = new Point(obj1.drawRect.Width, obj1.drawRect.Height);
        Point obj2Size = new Point(obj2.drawRect.Width, obj2.drawRect.Height);

        float distX;
        float distY;
        
        switch (collisionState)
        {
            case 1:                             //obj1's top coollides with obj2's bottom, move obj1 down and set Yvel to 0
                distY = Math.Abs(obj1Coor.Y - (obj2Coor.Y + obj2Size.Y));
                // If the ninja is on the ground, and a platform strikes his head, he gets squished and dies.
                if (obj1 is Player && obj2 is Platform && (obj2.velocity.Y > 0) && obj1.positionMask == PositionState.OnFloor)
                {
                    Player temp = (Player)obj1;
                    temp.death();
                    break;
                }
                obj1.MoveFrame(0, (int)distY);
                obj1.setVelocity(obj1.velocity.X, 0);
                obj2.setVelocity(obj2.velocity.X, 0);
                break;
            case 2:                             //obj1's right coollides with obj2's left,  move obj1 left and set Xvel to 0
                distX = Math.Abs(obj1Coor.X + obj1Size.X - obj2Coor.X);
                obj1.MoveFrame((int)-distX, 0);
                //obj1.setVelocity(0, obj1.velocity.Y);
                //obj2.setVelocity(0, obj2.velocity.Y);
                
                break;
            case 3:                             //obj1's bottom coollides with obj2's top, move obj1 up and set Yvel to 0                                            
                distY = Math.Abs(obj1Coor.Y + obj1Size.Y - obj2Coor.Y);
                obj1.MoveFrame(0, (int)-distY);
                // if a player hits a platform with more than a certain fallspeed, he dies on impact.
                if (obj1 is Player && obj1.velocity.Y >= WorldObject.terminalVelocity)
                {
                    Player temp = (Player)obj1;
                    temp.death();
                }
                obj1.setVelocity(obj1.velocity.X, 0); // Only stop this object from moving down.
                obj2.setVelocity(obj2.velocity.X, 0); // Only stop this object from moving up.
                obj1.setPositionState(PositionState.OnFloor);
                //if a platform stacks on top of another, we don't want it to continue to accelerate downwards
                if (obj1 is Platform) obj1.setGravity(false);
                // if a player hits a platform with more than a certain fallspeed, he dies on impact.
                break;
            case 4:                             //obj1's left coollides with obj2's right,  move obj1 right and set Xvel to 0
                distX = Math.Abs(obj1Coor.X - (obj2Coor.X + obj2Size.X));
                obj1.MoveFrame((int)distX, 0);
                //obj1.setVelocity(0, obj1.velocity.Y);
                //obj2.setVelocity(0, obj2.velocity.Y);
                
                break;
            default:
                throw new Exception("Invalid CollisionState: WorldObjectManager.collisionResolution");
                
        }
    }*/
    #endregion

    /// <summary>
    /// Pass the touch to the game world as a last resort.
    /// </summary>
    /// <param name="gesture"></param>
    public bool ProcessTouch(GestureSample gesture)
    {
        return commandMenu.ProcessTouch(gesture, listOfWorldPlatforms);
    }


}

